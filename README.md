# Micronets Manufacturer Usage Description (MUD) Tools

This repository is for managing tools and data related to the use of MUD within the 
Micronets project.

### 2.1 Quick Start

#### 2.1.1 Running the MUD Manager manually

From the micronets-mud-tools directory, perform the following steps:

Setup the virtualenv:
```
bin/setup-virtualenv-mudmanager.sh
```

Start the MUD manger:
```
virtualenv/bin/python bin/mudWS.py
```
(or if you plan to run the MUD Manager repeatedly, for debug/development)
```
source virtualenv/bin/activate
python bin/mudWS.py
```

You should see output similar to the following:
```
12/Dec/2018:22:53:57] ENGINE Bus STARTING
CherryPy Checker:
The Application mounted at '' has an empty config.

[12/Dec/2018:22:53:57] ENGINE Started monitor thread 'Autoreloader'.
[12/Dec/2018:22:53:57] ENGINE Serving on http://0.0.0.0:8888
[12/Dec/2018:22:53:57] ENGINE Bus STARTED
```

The MUD Manager can be stopped via Control-C. But it will also be stopped if/when the terminal session 
the proxy is started from terminates. It can also be run via "nohup". But running it via systemd is the
preferred method (see below).

#### 2.1.2 Running the MUD Manager using systemd

From the micronets-mud-tools directory, perform the following steps to setup the virtualenv:

Setup the virtualenv:
```
bin/setup-virtualenv.sh
```

An example systemd service control file `micronets-mud-manager.service` is provided in the source 
distribution. The "WorkingDirectory" and "ExecStart" entries need to be modified to match the
location of the MUD Manager virtualenv and python program. And the "User" and "Group" settings
should be set to the "micronets" user (or commented out to run as "root") E.g.

```
WorkingDirectory=/home/micronets-dev/Projects/micronets/micronets-infrastructure
ExecStart=/home/micronets-dev/Projects/micronets/micronets-infrastructure/virtualenv/bin/python bin/websocket-proxy.py
User=micronets-dev
Group=micronets-dev
```

The systemctl service unit file can be installed for the systemd service using:

```
sudo systemctl enable $PWD/micronets-mud-manager.service
sudo systemctl daemon-reload
```

Once the micronets-mud-manager service is installed, it can be run using:

```
sudo systemctl start micronets-mud-manager.service
```

Where the logging will be stored is system-dependent. On Ubuntu 16.04 systems
logging will be written to `/var/log/syslog`.

The status of the proxy can be checked using:

```
sudo systemctl status micronets-mud-manager.service
```

and the proxy stopped using:

```
sudo systemctl stop micronets-mud-manager.service
```

## 3. API Client Certs

### 3.1 Generating the shared root certificate used for micronets API component communication:

This will produce the root certificate and key for validating/generating
leaf certificates used by certain micronets API:

```
bin/gen-root-cert --cert-basename lib/micronets-api-root \
    --subject-org-name "Micronets API Root Cert" \
    --expiration-in-days 3650
```

This root cert is be the basis for trust for all the clients
communicating via select Micronets APIs. APIs will only 
trust peers that present a cert signed by this root cert. 
The API server must have client cert verification enabled/required 
and `lib/micronets-api-root.cert.pem` must be added to the API 
endpoint's list of trusted CAs (and should really be the only
CA enabled).

The `micronets-ws-root.key.pem` file generated by this script should
only be retained for the purposes of generating new leaf certs for the
websocket peers. It should not be deployed with any software 
components.

### 3.2 Generating API client certificates:

```
bin/gen-leaf-cert --cert-basename lib/micronets-api-client \
    --subject-org-name "Micronets API Client Cert" \
    --expiration-in-days 3650 \
    --ca-certfile lib/micronets-api-root.cert.pem \
    --ca-keyfile lib/micronets-api-root.key.pem

cat lib/micronets-api-client.cert.pem lib/micronets-api-client.key.pem > lib/micronets-api-client.pkeycert.pem
```

The `lib/micronets-api-client.pkeycert.pem` file must be deployed with any
micronet software component that needs to access a cert-controlleed micronets API.


## 4. Websocket message format

### 4.1 Base message definition

All messages exchanged via the websocket channel must have these fields:

```
{
   “message”: {
      “messageId”: <client-supplied session-unique string>,
      “messageType”: <string identifying the message type>,
      “requiresResponse”: <boolean>
      “inResponseTo”: <id string of the originating message> (optional)
   }
}
```

### 4.2 HELLO message definition

```
{
    "message": {
        "messageId": 0,
        "messageType": "CONN:HELLO",
        "peerClass": <string identifying the type of peer connecting to the websocket>,
        "peerId": <string uniquely identifying the peer in the peer class>,
        "requiresResponse": false
    }
}
```

Example:

```
{
    "message": {
        "messageId": 0,
        "messageType": "CONN:HELLO",
        "requiresResponse": false,
        "peerClass": "micronets-ws-test-client",
        "peerId": "12345678"
    }
}
```

### 4.3 REST Request definition

This defines a REST Request message:

```
“message”: {
   “messageType”: “REST:REQUEST”,
   “requiresResponse”: true,
   “method”: <HEAD|GET|POST|PUT|DELETE|…>,
   “path”: <URI path>,
   “queryStrings”: [{“name”: <name string>, “value”: <val string>}, …],
   “headers”: [{“name”: <name string>, “value”: <val string>}, …],
   “dataFormat”: <mime data format for the messageBody>
   “messageBody”: <either a string encoded according to the mime type, base64 string if dataFormat is “application/octet-stream”, or JSON object if dataFormat is “application/json”>
```

Note that Content-Length, Content-Type, and Content-Encoding should not be communicated via the "headers" element as they are conveyed via the dataFormat and messageBody elements. If the request is handled by a HTTP processing system, these header elements may need to be derived from dataFormat and messageBody.

Example GET request:

```
{
  "message": {
    "messageId": 3,
    "messageType": "REST:REQUEST",
    "requiresResponse": true,
    "method": "GET",
    "path": "/micronets/v1/dhcp/subnets",
    "headers": [
      {
        "name": "Host",
        "value": "localhost:5001"
      },
      {
        "name": "User-Agent",
        "value": "curl/7.54.0"
      },
      {
        "name": "Accept",
        "value": "*/*"
      }
    ]
  }
}
```

Example POST request:

```
{
  "message": {
    "messageId": 1,
    "messageType": "REST:REQUEST",
    "requiresResponse": true,
    "method": "POST",
    "path": "/micronets/v1/dhcp/subnets",
    "headers": [
      {
        "name": "Host",
        "value": "localhost:5001"
      },
      {
        "name": "User-Agent",
        "value": "curl/7.54.0"
      },
      {
        "name": "Accept",
        "value": "*/*"
      }
    ],
    "dataFormat": "application/json",
    "messageBody": {
      "subnetId": "mocksubnet007",
      "ipv4Network": {
        "network": "192.168.1.0",
        "mask": "255.255.255.0",
        "gateway": "192.168.1.1"
      },
      "nameservers": [
        "1.2.3.4",
        "1.2.3.5"
      ]
    }
  }
}
```

Example PUT request:

```
{
    "message": {
        "messageId": 3,
        "messageType": "REST:REQUEST",
        "requiresResponse": true,
        "method": "PUT",
        "path": "/micronets/v1/dhcp/subnets/mocksubnet007",
        "dataFormat": "application/json",
        "headers": [
           {"name": "Host", "value": "localhost:5001"},
           {"name": "User-Agent", "value": "curl/7.54.0"},
           {"name": "Accept", "value": "*/*"}
        ],
        "messageBody": {
            "ipv4Network": {
                "gateway": "192.168.1.3"
            }
        }
    }
}
```

### 4.4 REST Response definition

This defines a REST Response message:

```
{
    “message”: {
        “messageType”: “REST:RESPONSE”,
        "inResponseTo": <integer message ID of the REST:REQUEST that generated the response>
        “requiresResponse”: false,
        “statusCode”: <HTTP integer status code>,
        “reasonPhrase”: <HTTP reason phrase string>,
        “headers”: [{“name”: <name string>, “value”: <val string>}, ],
        “dataFormat”: <mime data format for the messageBody>,
        “messageBody”: <either a string encoded according to the dataFormat, base64 string if dataFormat is         “application/octet-stream”, or JSON object if dataFormat is “application/json”>
 “application/octet-stream”, or JSON object if dataFormat is “application/json”>
    }
}
```

Note that Content-Length, Content-Type, and Content-Encoding should not be communicated via the "headers" element as they are conveyed via the dataFormat and messageBody elements. If the request is handled by a HTTP processing system, these header elements may need to be derived from dataFormat and messageBody.

Example GET response:
```
{
    "message": { 
        "messageId": 2,
        "inResponseTo": 3,
        "messageType": "REST:RESPONSE",
        "reasonPhrase": null,
        "requiresResponse": false, 
        "statusCode": 200,
        "dataFormat": "application/json", 
        "messageBody": {
            "subnets": [
                {
                    "ipv4Network": {
                        "gateway": "192.168.30.2",
                        "mask": "255.255.255.0",
                        "network": "192.168.30.0"
                    }, 
                    "subnetId": "wireless-network-1"
                }, 
                {
                    "ipv4Network": {
                        "gateway": "192.168.40.1",
                        "mask": "255.255.255.0",
                        "network": "192.168.40.0"
                    }, 
                    "subnetId": "wired-network-3"
                },
                {
                    "ipv4Network": {
                        "gateway": "10.40.0.1",
                        "mask": "255.255.255.0",
                        "network": "10.40.0.0"
                    }, 
                    "nameservers": ["10.40.0.1"],
                    "subnetId": "testsubnet001"
                }
            ]
        }
    }
}
```

Example POST response:

```
{
    "message": {
        "messageId": 2,
        "inResponseTo": 1,
        "messageType": "REST:RESPONSE",
        "requiresResponse": false,
        "statusCode": 201
        "dataFormat": "application/json",
        "messageBody": {
            "subnet": {
                "subnetId": "mocksubnet007",
                "ipv4Network": {
                    "gateway": "192.168.1.1",
                    "mask": "255.255.255.0",
                    "network": "192.168.1.0"
                }, 
                "nameservers": ["1.2.3.4", "1.2.3.5"]
            }
        }
    }
}
```

Example PUT response:
```
 {
     "message": {
         "messageId": 2,
         "inResponseTo": 3,
         "messageType": "REST:RESPONSE",
         "requiresResponse": false,
         "statusCode": 200,
         "dataFormat": "application/json",
         "messageBody": {
             "subnet": {
                 "ipv4Network": {
                     "gateway": "192.168.1.3",
                     "mask": "255.255.255.0",
                     "network": "192.168.1.0"
                 },
                 "nameservers": ["1.2.3.4", "1.2.3.5"],
                 "subnetId": "mocksubnet007"
             }
         }
     }
 }
```

Example DELETE response:
```
{
    "message": {
        "messageId": 3,
        "inResponseTo": 5,
        "messageType": "REST:RESPONSE",
        "requiresResponse": false,
        "statusCode": 200
    }
}
```

### 4.5 Event Message definition

```
{
    “message”: {
        “messageType”: “EVENT:<client-supplied event name>”,
        “requiresResponse”: False,
        “dataFormat”: <mime data format for the messageBody>,
        “messageBody”: <either a string encoded according to the mime type, base64 string if dataFormat is “application/octet-stream”, or JSON object if dataFormat is “application/json”>
    }
}
```
